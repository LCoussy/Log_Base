import re
import json
import os

#from datetime import datetime, timedelta

filename = '/home/coussy/log-base/logUser.txt'

# Texte des données à analyser
data = """"""

with open(filename) as f:
  lines = f.readlines() # list containing lines of file
  for line in lines:
    if line != '\n':
      if "ligne" not in line:
        data += line


def get_aUserBlock(data):
  # i = 0
  # line = data.split('\n', i+1)[i]
  # while re.search(r"(\d{2}/\d{2}/\d{2})\s+(\d{2}:\d{2}:\d{2})\s+(\d{2}:\d{2}:\d{2})", line) == None:
  #   i+=1
  #   line = data.split('\n', i+1)[i]
  # dataTemp = data.split('\n', i+1)
  # dataTemp1 = "\n".join(dataTemp[:i+1])
  # return dataTemp1
  i = 0
  lines = data.split('\n')

  # Assurez-vous qu'il y a des lignes à analyser
  while i < len(lines) and re.search(r"(\d{2}/\d{2}/\d{2})\s+(\d{2}:\d{2}:\d{2})\s+(\d{2}:\d{2}:\d{2})", lines[i]) is None:
    i += 1

  # Si 'i' est maintenant égal à la longueur de 'lines', aucune correspondance n'a été trouvée
  if i == len(lines):
    return None  # ou lever une exception, ou renvoyer une chaîne vide

  dataTemp = "\n".join(lines[:i + 1])
  # print(dataTemp)
  # print('---------------------------')
  return dataTemp


def aUserParse(data):
  results = {
    "Environnement" : None,
    "PID" : int,
    "serviceNameOrUserProcessName" : {
      "ServiceName" : "",
      "UserProcessName" : {
        "UserName" : "",
        "DomainName" : ""
      }
    },
    "ProcessType" : "",
    "ProgramExecuted" : {
      "Name" : "",
      "SubProcess" : None
    },
    "Server" : {
      "Name" : "",
      "Domain" : None
    },
    "TimeInformation" : {
      "Start" : {
        "Date" : "",
        "Time" : ""
      },
      "TimeRunning" : ""
    },
    "logMessage" : ""
  }
  environnement_pattern = r"\b([A-Z]{2,4}\d{0,4})\b"
  last_number_pattern = r"(\d+)$"
  service_pattern = r"^svc_"
  user_name_pattern = r"(?:([A-Za-z0-9_]+)\\)?([A-Za-z0-9_]+)"

  # Vérifiez si `data` n'est pas vide
  # print(data)
  # print('--------------------')

  if data is None:
    return None

  if not data.strip():
    return None  # ou lever une exception selon votre logique

  results["logMessage"] = data

  match = re.search(environnement_pattern, data.split('\n', 1)[0])
  if match:
    results["Environnement"] = match.group(1)
    data = data.split('\n', 1)[1]
  else:
    results["Environnement"] = None  # ou lever une exception

  match = re.search(last_number_pattern, data.split('\n', 1)[0])
  if match:
    results["PID"] = match.group(1)
    data = data.split('\n', 1)[1]
  else:
    return None  # ou lever une exception

  if re.match(service_pattern, data):
    results["serviceNameOrUserProcessName"]["ServiceName"] = data.split('\n', 1)[0]
    results["serviceNameOrUserProcessName"]["UserProcessName"]["UserName"] = None
    results["serviceNameOrUserProcessName"]["UserProcessName"]["DomainName"] = None
  else:
    match = re.match(user_name_pattern, data.split('\n', 1)[0])
    if match:
      if match.group(1) == "":
        results["serviceNameOrUserProcessName"]["UserProcessName"]["DomainName"] = None
      else:
        results["serviceNameOrUserProcessName"]["UserProcessName"]["DomainName"] = match.group(1)
      results["serviceNameOrUserProcessName"]["UserProcessName"]["UserName"] = match.group(2)
    results["serviceNameOrUserProcessName"]["ServiceName"] = None
  data = data.split('\n', 1)[1] if len(data.split('\n', 1)) > 1 else ''

  # Type de processus
  match = re.search(r"(\b\w+\b)\s+\d+", data.split('\n', 1)[0])
  if match:
    results["ProcessType"] = match.group(1)
    data = data.split('\n', 1)[1] if len(data.split('\n', 1)) > 1 else ''

  if re.search(r"KTSJ", data) or re.search(r"QMON", data):
    data = data.split('\n', 1)[1] if len(data.split('\n', 1)) > 1 else ''


  # Extraction du nom du programme et du sous-processus
  match = re.search(r"([\w\-\.]+)(?:\s+\((\w+)\))?", data.split('\n', 1)[0])
  if match:
    # print(match.group(1), match.group(2))
    results["ProgramExecuted"]["Name"] = match.group(1)  # ORACLE.EXE
    results["ProgramExecuted"]["SubProcess"] = match.group(2) if match.group(2) else None  # PSP0
    data = data.split('\n', 1)[1] if len(data.split('\n', 1)) > 1 else ''

  # Nom du serveur
  if data:
    match = re.match(r"^(?P<domain>[^\\]+\\)?(?P<name>[^\\]+)$", data.split('\n', 1)[0])
    if match:
      results["Server"]["Name"] = match.group("name")
      results["Server"]["Domain"] = match.group("domain").rstrip('\\') if match.group("domain") else None

    data = data.split('\n', 1)[1] if len(data.split('\n', 1)) > 1 else ''

  match = re.search(r"(\d{2}/\d{2}/\d{2})\s+(\d{2}:\d{2}:\d{2})\s+(\d{2}:\d{2}:\d{2})", data.split('\n', 1)[0])
  if match:
    results["TimeInformation"]["Start"]["Date"] = match.group(1)  # 06/10/24
    results["TimeInformation"]["Start"]["Time"] = match.group(2)  # 05:48:00
    results["TimeInformation"]["TimeRunning"] = match.group(3)

  return results

def UsersParsing(data):
  result = {"Users" : {}}
  Block = get_aUserBlock(data)
  check = True
  while check == True:

    aUserParsed = aUserParse(Block)
    # print(aUserParsed)
    if aUserParsed is None:  # Vérifiez si aUserParsed a échoué
      print("Aucun utilisateur analysé, arrêt de l'analyse.")
      break
    name = None
    # print(aUserParsed["serviceNameOrUserProcessName"]["ServiceName"], aUserParsed["serviceNameOrUserProcessName"]["UserProcessName"])
    if aUserParsed["serviceNameOrUserProcessName"]["UserProcessName"]["UserName"] != None:
      if aUserParsed["serviceNameOrUserProcessName"]["UserProcessName"]["DomainName"] != None:
        name = "@".join([aUserParsed["serviceNameOrUserProcessName"]["UserProcessName"]["DomainName"], aUserParsed["serviceNameOrUserProcessName"]["UserProcessName"]["UserName"]])

        # name = r"{}\\{}".format(aUserParsed["serviceNameOrUserProcessName"]["UserProcessName"]["DomainName"], aUserParsed["serviceNameOrUserProcessName"]["UserProcessName"]["UserName"])
        # name = name.replace('\\\\', '\\')
      else :
        name = aUserParsed["serviceNameOrUserProcessName"]["UserProcessName"]["UserName"]
    else:
        name = aUserParsed["serviceNameOrUserProcessName"]["ServiceName"]

    # print(name)
    if name not in result["Users"]:
      result["Users"][name] = {}  # Initialisez un dictionnaire pour cet utilisateur/service

    pid = str(aUserParsed["PID"])
    if pid not in result["Users"][name]:
      result["Users"][name][pid] = aUserParsed.copy()  # Ajoutez l'entrée pour ce PID
      # result["Users"][name][pid]["logMessage"] = Block

    # print("-----------------------------------------------------------------------------------------------------")
    # print(json.dumps(result, indent=4))

    data = data.replace(Block, '', 1).strip()
    if re.search(r"D[ée]connect[ée] de Oracle Database [\w\s.]+ - \d{2}bit Production\s*-+\s*(\d{2}/\d{2}/\d{4})\s*(\d{2}:\d{2})\s*-+", data.split('\n', 1)[0]):
      check = False
      break
    Block = get_aUserBlock(data)

    # print("--------------------------------------------------------------------------------------------------")
    # print(result["Users"][name][pid]["ProgramExecuted"]["SubProcess"],result["Users"][name][pid]["logMessage"])
    # print("--------------")
    # print(result["Users"][name])


  # print(json.dumps(result, indent=4))

  # output_file = "/home/coussy/log-base/analyzed_data.json"

  # Chemin du répertoire et du fichier de sortie
  directory = "analyse/"
  output_file = os.path.join(directory, "analyzed_data.json")

  # Vérifier si le répertoire existe
  if not os.path.exists(directory):
      os.mkdir(directory)

  # Assurer que le répertoire est accessible en écriture
  if not os.access(directory, os.W_OK):
      os.chmod(directory, 0o777)


  # with open(output_file, 'w', encoding='utf-8') as f:
  #   json.dump(result, f, ensure_ascii=False, indent=4)
  # print(f"Données analysées et enregistrées dans {output_file}")
  with open(output_file, 'w', encoding='utf-8') as f:
      json.dump(result, f, ensure_ascii=False, indent=4)
  print(f"Données analysées et enregistrées dans {output_file}")


UsersParsing(data)
